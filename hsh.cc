#include <bits/stdc++.h>

using namespace std;

typedef long long i64;
typedef unsigned long long u64;
typedef unsigned int u32;
typedef pair<i64, u32> pii;

const i64 inf = 1000000007;
const i64 inf2 = inf*inf;
const int maxn = 200010;

/*
struct custom_hash {
  static uint64_t splitmix64(uint64_t x) {
    // http://xorshift.di.unimi.it/splitmix64.c
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }

  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
};

unordered_map<i64, i64, custom_hash> M;
*/


// std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
static int p1[256] = {
  1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121,1000133,1000151,1000159,1000171,1000183,1000187,1000193,1000199,1000211,1000213,1000231,1000249,1000253,1000273,1000289,1000291,1000303,1000313,1000333,1000357,1000367,1000381,1000393,1000397,1000403,1000409,1000423,1000427,1000429,1000453,1000457,1000507,1000537,1000541,1000547,1000577,1000579,1000589,1000609,1000619,1000621,1000639,1000651,1000667,1000669,1000679,1000691,1000697,1000721,1000723,1000763,1000777,1000793,1000829,1000847,1000849,1000859,1000861,1000889,1000907,1000919,1000921,1000931,1000969,1000973,1000981,1000999,1001003,1001017,1001023,1001027,1001041,1001069,1001081,1001087,1001089,1001093,1001107,1001123,1001153,1001159,1001173,1001177,1001191,1001197,1001219,1001237,1001267,1001279,1001291,1001303,1001311,1001321,1001323,1001327,1001347,1001353,1001369,1001381,1001387,1001389,1001401,1001411,1001431,1001447,1001459,1001467,1001491,1001501,1001527,1001531,1001549,1001551,1001563,1001569,1001587,1001593,1001621,1001629,1001639,1001659,1001669,1001683,1001687,1001713,1001723,1001743,1001783,1001797,1001801,1001807,1001809,1001821,1001831,1001839,1001911,1001933,1001941,1001947,1001953,1001977,1001981,1001983,1001989,1002017,1002049,1002061,1002073,1002077,1002083,1002091,1002101,1002109,1002121,1002143,1002149,1002151,1002173,1002191,1002227,1002241,1002247,1002257,1002259,1002263,1002289,1002299,1002341,1002343,1002347,1002349,1002359,1002361,1002377,1002403,1002427,1002433,1002451,1002457,1002467,1002481,1002487,1002493,1002503,1002511,1002517,1002523,1002527,1002553,1002569,1002577,1002583,1002619,1002623,1002647,1002653,1002679,1002709,1002713,1002719,1002721,1002739,1002751,1002767,1002769,1002773,1002787,1002797,1002809,1002817,1002821,1002851,1002853,1002857,1002863,1002871,1002887,1002893,1002899,1002913,1002917,1002929,1002931,1002973,1002979,1003001,1003003,1003019,1003039,1003049,1003087,1003091,1003097,1003103,1003109,1003111,1003133,1003141,1003193,1003199,1003201,1003241,1003259,1003273,1003279,1003291,1003307,1003337};
static int p2[256] = {
  1000004567,1000004569,1000004581,1000004609,1000004611,1000004627,1000004633,1000004647,1000004693,1000004699,1000004717,1000004771,1000004777,1000004783,1000004791,1000004807,1000004839,1000004843,1000004849,1000004857,1000004867,1000004869,1000004891,1000004893,1000004897,1000004927,1000004933,1000004977,1000004981,1000005001,1000005029,1000005053,1000005067,1000005103,1000005133,1000005187,1000005197,1000005203,1000005233,1000005277,1000005287,1000005299,1000005317,1000005329,1000005341,1000005353,1000005361,1000005403,1000005407,1000005437,1000005443,1000005449,1000005451,1000005469,1000005491,1000005527,1000005541,1000005547,1000005583,1000005631,1000005647,1000005683,1000005731,1000005737,1000005751,1000005763,1000005791,1000005823,1000005827,1000005833,1000005847,1000005863,1000005899,1000005907,1000005947,1000005953,1000005959,1000005971,1000005973,1000005991,1000005997,1000006019,1000006027,1000006037,1000006039,1000006061,1000006093,1000006099,1000006127,1000006129,1000006177,1000006193,1000006211,1000006223,1000006229,1000006307,1000006313,1000006331,1000006349,1000006379,1000006393,1000006417,1000006421,1000006457,1000006459,1000006477,1000006541,1000006571,1000006577,1000006583,1000006607,1000006621,1000006661,1000006663,1000006697,1000006717,1000006751,1000006781,1000006837,1000006867,1000006901,1000006957,1000006961,1000006967,1000006981,1000007003,1000007023,1000007027,1000007089,1000007117,1000007137,1000007147,1000007159,1000007191,1000007209,1000007237,1000007243,1000007257,1000007279,1000007321,1000007347,1000007383,1000007389,1000007417,1000007429,1000007447,1000007453,1000007467,1000007479,1000007497,1000007513,1000007521,1000007531,1000007537,1000007557,1000007633,1000007647,1000007651,1000007653,1000007681,1000007707,1000007719,1000007741,1000007759,1000007773,1000007803,1000007819,1000007837,1000007873,1000007887,1000007909,1000007923,1000007927,1000007929,1000007941,1000008041,1000008083,1000008089,1000008101,1000008109,1000008127,1000008173,1000008181,1000008223,1000008257,1000008259,1000008271,1000008277,1000008311,1000008313,1000008343,1000008349,1000008397,1000008403,1000008419,1000008431,1000008439,1000008487,1000008511,1000008557,1000008593,1000008617,1000008637,1000008649,1000008661,1000008671,1000008679,1000008719,1000008727,1000008761,1000008773,1000008791,1000008797,1000008803,1000008811,1000008829,1000008853,1000008899,1000008917,1000008937,1000008967,1000009009,1000009013,1000009063,1000009081,1000009093,1000009099,1000009123,1000009133,1000009163,1000009183,1000009211,1000009223,1000009259,1000009277,1000009279,1000009289,1000009301,1000009321,1000009331,1000009363,1000009399,1000009403,1000009421,1000009441,1000009457,1000009469,1000009487,1000009519,1000009529,1000009531,1000009541,1000009559,1000009561,1000009567,1000009573};

struct hshTwo {
  static const i64 M = p2[rng() & 255];
  i64 _x;
  u32 _y;
  hshTwo() {
    _x = 0;
    _y = 0;
  }
  hshTwo(i64 x, u32 y) {
    _x = x;
    _y = y;
  }
  hshTwo& operator+=(const hshTwo& rhs) {
    _x += rhs._x;
    if (_x >= M) {
      _x -= M;
    }
    _y += rhs._y;
    return *this;
  }
  hshTwo& operator-=(const hshTwo& rhs) {
    _x -= rhs._x;
    if (_x < 0) {
      _x += M;
    }
    _y -= rhs._y;
    return *this;
  }
  hshTwo& operator*=(const hshTwo& rhs) {
    _x = _x * rhs._x % M;
    _y *= rhs._y;
    return *this;
  }
  u64 toint() {
    return (_x << 32) | _y;
  }

  friend hshTwo operator+(const hshTwo& lhs, const hshTwo& rhs) {
    return hshTwo(lhs) += rhs;
  }
  friend hshTwo operator-(const hshTwo& lhs, const hshTwo& rhs) {
    return hshTwo(lhs) -= rhs;
  }
  friend hshTwo operator*(const hshTwo& lhs, const hshTwo& rhs) {
    return hshTwo(lhs) *= rhs;
  }
};

void initH(char s[], int n, hshTwo f[], hshTwo h[]) {
  f[0] = hshTwo{1, 1};
  h[0] = hshTwo{0, 0};
  hshTwo bas{9901, 10007};
  for (int i = 1; i <= n; ++i) {
    f[i] = f[i-1] * bas;
    h[i] = h[i-1] * bas + hshTwo{s[i], (u32)s[i]};
  }
}
inline hshTwo seghsh(int l, int r, hshTwo f[], hshTwo h[]) {
  return h[r] - h[l-1] * f[r-l+1];
}

/*
   struct hshOne {
   u64 _x;
   hshOne() {
   _x = 0;
   }
   hshOne(i64 x) {
   _x = x;
   }
   hshOne& operator+=(const hshOne& rhs) {
   _x += rhs._x;
   return *this;
   }
   hshOne& operator-=(const hshOne& rhs) {
   _x -= rhs._x;
   return *this;
   }
   hshOne& operator*=(const hshOne& rhs) {
   _x *= rhs._x;
   return *this;
   }
   friend hshOne operator+(const hshOne& lhs, const hshOne& rhs) {
   return hshOne(lhs) += rhs;
   }
   friend hshOne operator-(const hshOne& lhs, const hshOne& rhs) {
   return hshOne(lhs) -= rhs;
   }
   friend hshOne operator*(const hshOne& lhs, const hshOne& rhs) {
   return hshOne(lhs) *= rhs;
   }
   };

   void initH(char s[], int n, hshOne f[], hshOne h[]) {
   f[0] = hshOne{1};
   h[0] = hshOne{0};
   hshOne bas{9901};
   for (int i = 1; i <= n; ++i) {
   f[i] = f[i-1] * bas;
   h[i] = h[i-1] * bas + hshOne{s[i]};
   }
   }
   inline hshOne seghsh(int l, int r, hshOne f[], hshOne h[]) {
   return h[r] - h[l-1] * f[r-l+1];
   }
 */
